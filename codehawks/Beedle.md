# Introduction

A security review of the **Beedle** protocol was done by **iurii2002** as part of **codehawks**  [contest](https://www.codehawks.com/contests/clkbo1fa20009jr08nyyf9wbx).


# Findings Summary

| ID     | Title                   | Severity |
| ------ | ----------------------- | -------- |
| [H-01] | sellProfits call might be front-run     | High     |
| [M-01] | Lender may front-run borrowing to set higher InterestRate   | Medium   |
| [M-02] | sellProfits funciton may not be usable due to UniswapV3 pools configuration   | Medium   |
| [M-03] | One step ownership transfer may cause to transfer to a non-existent or mistyped address   | Medium   |
| [G-01] | Unnecessery check in Staking contract   | Gas   |
| [G-02] | No need to explicitly set storage variable value to 0   | Gas   |
| [G-03] | Unnecessery function in the Beedle.sol contract      | Gas      |

# Detailed Findings

# [H-01] sellProfits call might be front-run

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Fees.sol#L38C1-L38C37

## Summary

Fees contract allow swapping fees generated by the protocol in form of collateral tokens to be swapped to WETH and transfered to Staking contract.

## Vulnerability Details

Current `sellProfits` function calls Uniswap V3 ExactInputSingleParams function with hard-coded amountOutMinimum 0. That will allow swap to go through no matter how many weth we will get from the swap.

## Impact

MEV sandwich bots may front-run contract's swap call and received weth amount might be much lower then anticipated.

According to the Uniswap docs - `For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation`

## Tools Used

Observation

## Recommendations

Change `sellProfits` function implementation to calculate amountOutMinimum

# [M-01] Lender may front-run borrowing to set higher InterestRate

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Lender.sol#L221C1-L221C81

## Summary

`updateInterestRate` function within the `Lender.sol` contract allows lender to change interest rate for all new loans made from the pool.

## Vulnerability Details

Malicious lender may scan mempool and if new borrow tx appears, front-run it with setting higher interest rate.

## Impact

It is borrower duty to check if this happened and close loan as soon is possible. However, as the max interest rate capped to 1000%, even 1 day of such a loan will lead to almost 3% loss for borrower.

## Tools Used

Observation

## Recommendations

Consider adding timelock for interest rate change. For example, allow lenders to make changes in the next block

# [M-02] sellProfits funciton may not be usable due to UniswapV3 pools configuration

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Fees.sol#L34C1-L34C27

## Summary

Fees contract allow swapping fees generated by the protocol in form of collateral tokens to be swapped to WETH and transfered to Staking contract.

## Vulnerability Details

Current `sellProfits` function calls Uniswap V3 ExactInputSingleParams function with hard-coded fee 3000, which will effectively use Uniswap pool with 0.3% fee. While 0.3% fee pool are most common for Uniswap, pools might be also created with 0.05% or 1% fees. It's crucial to use the correct fee value that corresponds to the actual fee tier used in the liquidity pool to get accurate results when using Uniswap's ExactInputSingle function. Incorrect usage can lead to financial losses or undesired outcomes.

## Impact

Effectively, if we use current implementation of `sellProfits` for the token pair were non 0.3% implemented we may get worse price or get transaction reverted. For example USDC/ETH 0.05% pool has $270 mln liquidity, while 0.3% pool only $2.7 mln. Thus slippage will be much higher within 0.3%

## Tools Used

Observation

## Recommendations

Allow different fee tier implementation for different assets

# [M-03] One step ownership transfer may cause to transfer to a non-existent or mistyped address

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Lender.sol#L10

## Summary

Protocol implements Ownable contract that allows to set Lender contract owner and transfer owner with transferOwnership function

```solidity
    function transferOwnership(address _owner) public virtual onlyOwner {
        owner = _owner;
        emit OwnershipTransferred(msg.sender, _owner);
    }
```


## Vulnerability Details

Ownable is common implementation of contract's ownership, however, it has a shortcoming that it allows the owner to transfer ownership to a non-existent or mistyped address.

## Impact

In this case, team will lose access to Governance functions of `Lender.sol` contract - `setLenderFee`, `setBorrowerFee`, `setFeeReceiver` and thus won't be able to change these variables in case of necessity.

## Tools Used

Observation

## Recommendations

Use openzeppelin [Ownable2Step](https://docs.openzeppelin.com/contracts/4.x/api/access#Ownable2Step) contract. Ownable2Step is safer than Ownable for smart contracts because the owner cannot accidentally transfer smart contract ownership to a mistyped address. Rather than directly transferring to the new owner, the transfer only completes when the new owner accepts ownership.

# [G-01] Unnecessery check in Staking contract

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Staking.sol#L67C1-L67C33

## Summary

Staking contract has update function to update global index of earned rewards

## Vulnerability Details

This function has the following code:

```solidity
    if (_balance > balance) {
        uint256 _diff = _balance - balance;
        if (_diff > 0) {
```

Where if first clause (_balance > balance) is true, the second one (_diff) will always be true.

## Impact

Extra gas usage for unnecessary check

## Tools Used

Observation

## Recommendations

Delete second if statement

# [G-02] No need to explicitly set storage variable value to 0

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Staking.sol#L13C1-L16C30

## Summary

Staking contract has `balance` and `index` variables stored in storage.

## Vulnerability Details

During deployment these variable values set to 0. That is not necessary as default uint256 variable value is already 0. While explicitly setting these variables to 0 we use additional gas.

## Impact

Extra gas is used

## Tools Used

Observation

## Recommendations

Change code to
    ```solidity
        /// @notice the balance of reward tokens
        uint256 public balance;
        /// @notice the index of the last update
        uint256 public index;
    ```


# [G-03] Unnecessery function in the Beedle.sol contract

## Relevant GitHub Links

https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Beedle.sol#L29C1-L34C6
https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Beedle.sol#L15C1-L20C6
https://github.com/Cyfrin/2023-07-beedle/blob/658e046bda8b010a5b82d2d85e824f3823602d27/src/Beedle.sol#L22C1-L27C6

## Summary

Beedle token contract implements 4 functions apart from inherited function from Ownable, ERC20, ERC20Permit, ERC20Votes. These function are _afterTokenTransfer, _mint, _burn and mint. Only 'mint' function is needed and should be left in the contract.

## Vulnerability Details

Functions `_afterTokenTransfer` and `_burn` are internal and can only be called internally within the contract or by the contracts inherited from the current one. They are not called inside of the contract and won't be reachable.

Function `_mint` is used in constructor, but as it simple calls the parent contract `super._mint(to, amount)` there is no particular reason to add it here.

## Impact

Additional gas is used for contract deployment that might be saved.

## Tools Used

Observation.

## Recommendations

Delete unnecessary functions


# Result

[Final report](https://www.codehawks.com/report/clkbo1fa20009jr08nyyf9wbx)

| Severity | Found | Total |
| ------ | ------ | -------- |
| High | 1     | 26     |
| Medium | 3   | 45   |
| Low | 0   | 28   |
| Gas | 3   | 110   |


Place - 125/276  
Reward - $19 
