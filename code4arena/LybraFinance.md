# Introduction

A security review of the **Lybra Finance** protocol was done by **iurii2002** as part of **code4arena**  [contest](https://code4rena.com/contests/2023-06-lybra-finance#top).

Huge thanks to [@pashovkrum](https://twitter.com/pashovkrum) for audit reporting template.

# Disclaimer

This report represent my own vision of project vulnarabilities and may not cover all 100% coverage of the project docs.

# About **Lybra Finance**

Lybra Finance is a protocol witch main object is creatin secure, interest-bearing,  decentralized, omnichain stablecoin - eUSD/peUSD. Protocol uses Liquid Staking Derivatives (LSD) assets as a collateral for eUSD/peUSD. 

eUSD is an interest-bearing ERC20-like token. User gets eUSD by providing interest-bearing LSD asset (stETH) to the vaults. 
PeUSD is a stable, interest-free ERC20-like token. User gets peUSD by 1:1 convertion or by providing non-rebase LSD asset (rETH, wstETH, wbETH)

PeUSD then may used as a stablecoin for general activities in various chains, as it implements LayerZero's cross-chain functionality.

User Flow:
1. Deposit ETH, stETH, wstETH, rETH, wbETH or other LSD asset to Lybra Finance
2. Borrow eUSD/peUSD from Lybra Finance
3. Use stablecoin for general activites while maintaining LSD income generated by LSD assets.

Protocol has LBR token that may be locked for esLBR token used for governance.

## Automated findings 

Automated findings output for the audit can be found [here](https://gist.github.com/liveactionllama/27513952718ec3cbcf9de0fda7fef49c).

## Privileged Roles & Actors

There are 4 main roles in Lybra Finance governance:
 - GOV - admin role for all other three roles, has ultimate pover to grant roles to DAO, TIMELOCK and ADMIN. 
 At the time of deployment of the governanceTimelock contract msg.sender will be granted GOV role without possibility to change the GOV of the contracts;
 - DAO - A time-locked contract initiated by esLBR voting, with a minimum effective period of 14 days. After the vote is passed, only the developer can execute the action. 
 At the time of deployment of the governanceTimelock contract msg.sender will also get this role.
 - TIMELOCK - A time-locked contract controlled by the developer, with a minimum effective period of 2 days.;
 - ADMIN - A multisignature account controlled by the developer. May set to pause minting trough setvaultMintPaused() function in LybraConfigurator.sol


# Severity classification

| Severity               | Impact: High | Impact: Medium | Impact: Low |
| ---------------------- | ------------ | -------------- | ----------- |
| **Likelihood: High**   | Critical     | High           | Medium      |
| **Likelihood: Medium** | High         | Medium         | Low         |
| **Likelihood: Low**    | Medium       | Low            | Low         |

**Impact** - the technical, economic and reputation damage of a successful attack

**Likelihood** - the chance that a particular vulnerability gets discovered and exploited

**Severity** - the overall criticality of the risk

# Security Assessment Summary

**_review commit hash_ - [5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6](https://github.com/code-423n4/2023-06-lybra)**

### Scope

The following smart contracts were in scope of the audit:

- `LBR.sol`
- `PeUSDMainnetStableVision.sol`
- `EUSD.sol`
- `esLBR.sol`
- `PeUSD.sol`
- `LybraProxyAdmin.sol`
- `LybraProxy.sol`
- `AdminTimelock.sol`
- `LybraGovernance.sol` 
- `GovernanceTimelock.sol`
- `LybraWbETHVault.sol`
- `LybraWstETHVault.sol`
- `LybraRETHVault.sol`
- `LybraStETHVault.sol`
- `LybraEUSDVaultBase.sol`
- `LybraPeUSDVaultBase.sol`
- `LybraConfigurator.sol`
- `esLBRBoost.sol`
- `EUSDMiningIncentives.sol`
- `stakerewardV2pool.sol`
- `ProtocolRewardsPool.sol`

The following number of issues were found, categorized by their severity:

- Critical & High: 3 issues
- Medium: 7 issues
- Low: 6 issues
- Gas optimization: 2 issues

---

# Findings Summary

| ID     | Title                   | Severity |
| ------ | ----------------------- | -------- |
| [C-01] | Received peUSD cannot be converted to eUSD | Critical |
| [C-02] | Function getAssetPrice for rETH and wbETH will always revert | Critical |
| [H-01] | `_voteSucceeded` function will return false if vote succeeded and vice versa  | High     |
| [M-01] | Possible governance collision due to two contracts with the DAO role    | Medium   |
| [M-02] | Ultimate power of the `GovernanceTimelock.sol` deployer may be a vector for centralization attack    | Medium   |
| [M-03] | DAO vote quorum will be almost impossible to reach    | Medium   |
| [M-04] | Significant stETH:ETH depeg will lead to project losses    | Medium   |
| [M-05] | `rigidRedemption` function will overestimate the user's `providerCollateralRatio`    | Medium   |
| [M-06] | Incorrect borrowed[_onBehalfOf] and poolTotalPeUSDCirculation calculation during PeUSD _repay    | Medium   |
| [M-07] | Centralization attack vectors are present in the code    | Medium   |
| [L-01] | Wrong interface used      | Low      |
| [L-02] | Insufficient checks      | Low      |
| [L-03] | Vaults not usable for assets with cdecimals < 18      | Low      |
| [L-04] | Wrong notations      | Low      |
| [L-05] | Unused safeMath library      | Low      |
| [L-06] | Check in setLockStatus might be done incorrectly       | Low      |
| [G-01] | Unnecessary variable assignment      | Gas      |
| [G-02] | Check before transfer would save gas cost in case of revert      | Gas      |

# Detailed Findings

# [C-01] Received peUSD cannot be converted to eUSD

## Severity

**Impact:** High, as it will result in the impossibility to use peUSD

**Likelihood:** High, as any peUSD transfer will lead to this error

## Description
The conversion between eUSD and peUSD is implemented in the `PeUSDMainnetStableVision.sol` contract. The conversion from eUSD to peUSD is available for all eUSD holders through the `convertToPeUSD` and `convertToPeUSDAndCrossChain` functions. However, the conversion from peUSD to eUSD is only possible for users who have previously converted an equal or greater amount to peUSD.

The current require statement prevents anyone who has received peUSD through the `transfer` or `transferFrom` functions from redeeming it as eUSD, effectively making it unusable.

```solidity
require(peusdAmount <= userConvertInfo[msg.sender].mintedPeUSD ... )
```


## Recommendations
The current implementation of the `PeUSDMainnetStableVision` contract keeps a record of each used `mintedPeUSD` within the `userConvertInfo` mapping. In order to allow users to convert received peUSD, the current approach needs to be updated. The team should decide on the appropriate changes to be made in the contracts.


# [C-02] Function getAssetPrice for rETH and wbETH will always revert

## Severity

**Impact:** High, as it will not allow the use of rETH and wbETH vaults

**Likelihood:** High, as the vaults will be unusable

## Description
The function `getAssetPrice` in the `LybraRETHVault.sol` and `LybraWbETHVault.sol` contracts internally calls the rETH or wbETH contract to retrieve the current token price in comparison to ETH. This information is used by Lybra Finance to calculate the actual price of the wbETH and rETH contracts during depositing, minting, liquidation calculations, and withdrawing from the pool.

The current implementation of `getAssetPrice` calls the `exchangeRatio` function, while the correct function names are `getExchangeRate` for rETH and `exchangeRate` for wbETH.

## Recommendations
Change code in `LybraRETHVault.sol` to
```solidity
    function getAssetPrice() public override returns (uint256) {
        return (_etherPrice() * IRETH(address(collateralAsset)).getExchangeRate()) / 1e18;
    }
```

Change code in `LybraWbETHVault.sol` to

```solidity
    function getAssetPrice() public override returns (uint256) {
        return (_etherPrice() * IWBETH(address(collateralAsset)).exchangeRate()) / 1e18;
    }
```

# [H-01] `_voteSucceeded` function will return false if vote succeeded and vice versa

## Severity

**Impact:** Medium, as it will make it impossible to execute a DAO vote that has succeeded, but it won't directly affect funds 

**Likelihood:** High, as it will affect all government votes


## Description

According to the `LybraGovernance.sol` contract, lines 120-122 store the `forVotes` in `proposalData[proposalId].supportVotes[0]`, while `againstVotes` are stored in `proposalData[proposalId].supportVotes[1]`.

```solidity
    forVotes =  proposalData[proposalId].supportVotes[0];
    againstVotes =  proposalData[proposalId].supportVotes[1];
    abstainVotes =  proposalData[proposalId].supportVotes[2];
```

A vote is considered successful when the `forVotes` count is greater than the `againstVotes` count. However, the `_voteSucceeded` function returns true when the opposite condition is met (i.e., when `againstVotes` is greater than `forVotes`).

## Recommendations
Change the comparison in `_voteSucceeded` function to:
```solidity
    return proposalData[proposalId].supportVotes[0] > proposalData[proposalId].supportVotes[1]
```

# [M-01] Possible governance collision due to two contracts with the DAO role 

## Severity

**Impact:**  High, as a non-DAO contract may execute DAO functions, rendering esLBR unnecessary for governance

**Likelihood:** Low, as it requires a malicious or compromised account owner/admin account


## Description
During the deployment of the `GovernanceTimelock.sol` contract, two accounts are granted the DAO role:

```solidity
    _grantRole(DAO, address(this));
    _grantRole(DAO, msg.sender);
```
While the reason for such deployment is not clear, there should only be one contract with the DAO role that is actually controlled by the DAO voters.

## Recommendations
Delete one of the DAO role assignments and use it only for the DAO governance contract.


# [M-02] Ultimate power of the `GovernanceTimelock.sol` deployer may be a vector for centralization attack

## Severity

**Impact:**  High, as this account may grant and revoke all roles in the project

**Likelihood:** Low, as it requires a malicious or compromised account owner/admin account


## Description
During the deployment of the `GovernanceTimelock.sol` contract, the `msg.sender` is granted the GOV role. Consequently, this account has ultimate power to grant or revoke any other role within the project.

In the event of account compromise or other malicious activity:
* The TIMELOCK or DAO role could be granted to a malicious contract without time lock delays, allowing changes to the project configuration to be made without delay.
* Roles may be revoked from genuine government accounts, potentially leading to the team and DAO losing control.

## Recommendations
Implement multisign contract or other precautionary measures to mitigate this risk.


# [M-03] DAO vote quorum will be almost impossible to reach

## Severity

**Impact:**  Medium, as some government votes would be hard to execute and the DAO would not work properly

**Likelihood:** Medium, as the quorum is still possible to reach but with a higher number of votes than anticipated


## Description
The governance quorum is reached when the sum of votes is greater than the quorum threshold. However, the current implementation of the `_quorumReached` function only considers the sum of `against` votes and `abstain` votes, without taking into account the for votes.

According to the `LybraGovernance.sol` contract, lines 121-122 store the `againstVotes` and `abstainVotes`:

```solidity
    againstVotes =  proposalData[proposalId].supportVotes[1];
    abstainVotes =  proposalData[proposalId].supportVotes[2];
```

As a result, the quorum will only be reached based on `against` and `abstain` votes, without considering the `for` votes.


## Recommendations
Use the total number of votes as the basis for calculating `_quorumReached`:

```solidity
    function _quorumReached(uint256 proposalId) internal view override returns (bool){
        return proposalData[proposalId].totalVotes >= quorum(proposalSnapshot(proposalId));
    }
```

# [M-04] Significant stETH:ETH depeg will lead to project losses

## Severity

**Impact:**  High, as stETH/ETH price fluctuation may cause significant damage to the project.

**Likelihood:** Low, as the stETH price would have to significantly deviate from ETH to cause damage to the project.


## Description
The project assumes that the price of stETH is equal to ETH, but in reality, this may not be the case. Currently, the price difference is negligible. However, historical data shows that the biggest stETH depeg was 7%. Although such a market condition is highly unlikely, a significant depeg of stETH could have critical implications for the project. For example, a depeg of more than 37.5% would allow users to borrow more than they deposited with the default setSafeCollateralRatio of 160.

## Recommendations
Use the stETH price feed instead of ETH to ensure accurate pricing and mitigate the risks associated with significant depegging.



# [M-05] `rigidRedemption` function will overestimate the user's `providerCollateralRatio`

## Severity

**Impact:** High, as using the wrong base for calculating the collateral ratio will result in the inability to use `rigidRedemption` in a timely manner.

**Likelihood:** Low, as it would require the collateral ratio to be very close to the threshold.


## Description

A user's debt consists of two parts: `feeStored[user]` and `borrowed[_onBehalfOf]`. The `providerCollateralRatio` calculation in the `rigidRedemption` function does not take into account the fees to be covered by the user, leading to an overestimation of the collateral ratio by a small margin.

```solidity
    uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];
```

While the deviation from the correct `providerCollateralRatio` may not be critical due to the 2% APY set for borrowing, it can still result in inefficient work for the `Redemption Provider`.

## Recommendations
Change of `borrowed[provider]` to `getBorrowedOf(provider)`:
```solidity
    uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / getBorrowedOf(provider); 
```


# [M-06] Incorrect borrowed[_onBehalfOf] and poolTotalPeUSDCirculation calculation during PeUSD _repay

## Severity

**Impact:** Low, as the borrowing APY is only 2%.
 
**Likelihood:** High, as all user debts will be calculated incorrectly.


## Description

A user's debt consists of two parts: `feeStored[user]` and `borrowed[_onBehalfOf]`. When executing the _repay function, the first step is to cover the `feeStored[user]` amount. The remaining amount should be deducted from the `borrowed[_onBehalfOf]` debt. However, the current implementation subtracts the whole amount instead of deducting only the difference:

```solidity
    borrowed[_onBehalfOf] -= amount;
    poolTotalPeUSDCirculation -= amount;
```

Furthermore, these changes to `borrowed[_onBehalfOf]` and `poolTotalPeUSDCirculation` should only be made if the repayment amount is greater than the total fee, as the `poolTotalPeUSDCirculation` does not include the `feeStored` amount.

## Recommendations
Move these lines into the true branch of the if(amount >= totalFee) statement:
```solidity
    borrowed[_onBehalfOf] -= amount - totalFee;
    poolTotalPeUSDCirculation -= amount - totalFee; 
```


# [M-07] Centralization attack vectors are present in the code

## Severity

**Impact:** High, as all users may lose peUSD.

**Likelihood:** Low, as it requires a malicious or compromised `mintVault` account.


## Description
The `transferFrom` function in `PeUSDMainnetStableVision` can be used by the `mintVault` without reducing the allowance. It is unclear why the `mintVault` is allowed to use the `transferFrom` function without requiring an allowance, but this poses a significant risk to all peUSD holders.

## Recommendations
Deleting this line will prevent the `mintVault` from using user funds:
```solidity
    if (!configurator.mintVault(spender))
``` 


# [L-01] Wrong interface used

During initiation of tokens in `LybraConfiguration.sol` wrong interface is used. 
```solidity
    if (address(peUSD) == address(0)) peUSD = IEUSD(_peusd);
```

Should use IPeUSD instead of IEUSD. However, this mistake won't escalate into bigger error as IEUSD interface has all necessary functions


# [L-02] Insufficient checks
`setTokenMiner` function in `LybraConfigurator.sol` contract may revert due to array length discrepancies. `setTokenMiner` function has two arguments - array of `_contracts` and array of `_bools`. In case their length is not equal function will revert while using extensive amount of gas in a for loop. Adding such requirement will save gas in case of this situation
```solidity
require(_contracts.length == _bools.length, "Length of contracts not equal to bools"); 
``` 

# [L-03] Vaults not usable for assets with cdecimals < 18
Currently Lybra Vaults may be used with 18-decimal LSD assets - stETH, wstETH, rETH, wbETH. 

As it stated in Lybra docs "_Collateral is any asset that a borrower must provide to take out a loan, acting as security for the debt._" 
Should there appear LSD asset with lower decimals, or if team decides to add 6-decimal USDC/USDT as a possible collateral this requirement would be passed only with much bigger amount then anticipated. 
```solidity
    require(assetAmount >= 1 ether, "")
``` 
For 6 decimal assets user would need to deposit 1_000_000_000_000 token to pass this requirement.

# [L-04] Wrong notations
Should use `collateral asset` instead of `stETH`
`LybraPeUSDVaultBase.sol` contract lines 80, 123, 149

0xae78736Cd615f374D3085123A210448E74Fc6393 is rETH address, correct wbETH address is 0xa2E3356610840701BDf5611a53974510Ae27E2e1
`LybraWbETHVault.sol` contract line 16

Actual ,ax supply is 100_000_000
`esLBR.sol` contract line 6

Functions has _the contract must not be paused_ in notation but actually do not implement any check for pause
`EUSD.sol` contract lines 149, 196, 222, 246, 266, 330, 364, 389

# [L-05] Unused safeMath library
`EUSD.sol` imports `SafeMath` library and uses it for most arithmetical operations. 
But in two occasions += and -= used. Consider changing to `SafeMath` .add/.sub for consistency 
Lines 425, 444

# [L-06] Check in setLockStatus might be done incorrectly 

Considering Lybra Fincance allow users to only extend the time of lock-up in `esLBRBoost.sol` contract, this require statement is not correctly implemented.
```solidity
    require(userStatus.duration <= _setting.duration, "Your lock-in period has not ended, and the term can only be extended, not reduced.");
```

For example
* user's current LockStatus is (unlockTime = +7 days from now; duration = 90 days, miningBoost = 30 * 1e18) 
* user want to change in to (unlockTime = +30 days from now; duration = 30 days, miningBoost = 20 * 1e18)
* his lock-up time will increase from 7 to 30 days, but it is currently not allowed as overall duration will be lowered.

Team should consider rewriting requirement to
```solidity
    require(userStatus.unlockTime <= block.timestamp + _setting.duration, "Your lock-in period has not ended, and the term can only be extended, not reduced."); 
``` 



# [G-01] Unnecessary variable assignment
`LybraRETHVault.sol` contract has rETH pool address stored as part of the contract and once again assigned during deployment. Should delete the original assignment.


# [G-02] Check before transfer would save gas cost in case of revert
Move `_checkHealth` berofe `transfer` in `LybraEUSDVaultBase.sol` contract line 109 


# Code4Arena results

[Code4Arena report](https://code4rena.com/reports/2023-06-lybra#h-02-doesnt-calculate-the-current-borrowing-amount-for-the-provider-including-the-providers-borrowed-shares-and-accumulated-fees-due-to-inconsistency-in-collateralratio-calculation)

High findings - 2/8. (3/8)
I actually found H-02 from report too, but somehow managed to mess with wording and got unqualified as low quality report.  
Medium findings - 2/23
Low/NC finding - 1/9

Got 29 place out of 132 wardens and $318 reward
